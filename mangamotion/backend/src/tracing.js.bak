/**
 * OpenTelemetry Tracing Module
 * 
 * Provides distributed tracing with Jaeger export:
 * - Automatic HTTP instrumentation
 * - Manual span creation for business logic
 * - Trace context propagation
 * - Sampling configuration
 * - Jaeger exporter
 */

const { NodeTracerProvider } = require('@opentelemetry/node');
const { getNodeAutoInstrumentations } = require('@opentelemetry/auto-instrumentations-node');
const { registerInstrumentations } = require('@opentelemetry/instrumentation');
const { JaegerExporter } = require('@opentelemetry/exporter-trace-jaeger');
const { BatchSpanProcessor } = require('@opentelemetry/sdk-trace-base');
const { W3CTraceContextPropagator } = require('@opentelemetry/core');
const { CompositePropagator } = require('@opentelemetry/core');
const { JaegerPropagator } = require('@opentelemetry/propagator-jaeger');
const { trace, context } = require('@opentelemetry/api');

const TRACING_ENABLED = process.env.TRACING_ENABLED !== 'false';
const JAEGER_HOST = process.env.JAEGER_HOST || 'localhost';
const JAEGER_PORT = parseInt(process.env.JAEGER_PORT || '6831', 10);
const JAEGER_SAMPLER = process.env.JAEGER_SAMPLER || 'const';
const JAEGER_SAMPLER_PARAM = parseFloat(process.env.JAEGER_SAMPLER_PARAM || '1.0');
const SERVICE_NAME = process.env.SERVICE_NAME || 'mangamotion-backend';

let tracer = null;

/**
 * Initialize tracing
 */
function initializeTracing() {
  if (!TRACING_ENABLED) {
    console.log('[Tracing] Tracing disabled');
    return null;
  }

  try {
    // Create Jaeger exporter
    const jaegerExporter = new JaegerExporter({
      host: JAEGER_HOST,
      port: JAEGER_PORT,
      serviceName: SERVICE_NAME,
      sampler: {
        type: JAEGER_SAMPLER,
        param: JAEGER_SAMPLER_PARAM
      }
    });

    // Create tracer provider
    const tracerProvider = new NodeTracerProvider();

    // Add Jaeger exporter
    tracerProvider.addSpanProcessor(new BatchSpanProcessor(jaegerExporter));

    // Register auto-instrumentations
    registerInstrumentations({
      instrumentations: [getNodeAutoInstrumentations()]
    });

    // Set global tracer provider
    trace.setGlobalTracerProvider(tracerProvider);

    // Set propagators
    const propagator = new CompositePropagator({
      propagators: [
        new W3CTraceContextPropagator(),
        new JaegerPropagator()
      ]
    });

    // Get tracer
    tracer = trace.getTracer(SERVICE_NAME, '1.0.0');

    console.log(`[Tracing] Initialized with Jaeger at ${JAEGER_HOST}:${JAEGER_PORT}`);
    return tracer;
  } catch (err) {
    console.error('[Tracing] Failed to initialize:', err);
    return null;
  }
}

/**
 * Get current tracer
 */
function getTracer() {
  if (!tracer && TRACING_ENABLED) {
    initializeTracing();
  }
  return tracer;
}

/**
 * Create a span for an operation
 */
function startSpan(name, attributes = {}) {
  const tracer = getTracer();
  if (!tracer) return null;

  const span = tracer.startSpan(name);
  
  // Add attributes
  for (const [key, value] of Object.entries(attributes)) {
    if (value !== undefined && value !== null) {
      span.setAttribute(key, value);
    }
  }

  return span;
}

/**
 * Create a span and run a function within it
 */
async function withSpan(name, fn, attributes = {}) {
  const tracer = getTracer();
  if (!tracer) {
    return fn();
  }

  const span = tracer.startSpan(name);
  
  // Add attributes
  for (const [key, value] of Object.entries(attributes)) {
    if (value !== undefined && value !== null) {
      span.setAttribute(key, value);
    }
  }

  try {
    return await context.with(trace.setSpan(context.active(), span), fn);
  } catch (err) {
    span.recordException(err);
    span.setStatus({ code: 2, message: err.message }); // ERROR status
    throw err;
  } finally {
    span.end();
  }
}

/**
 * Add event to current span
 */
function addEvent(name, attributes = {}) {
  const span = trace.getActiveSpan();
  if (!span) return;

  span.addEvent(name, attributes);
}

/**
 * Set attribute on current span
 */
function setAttribute(key, value) {
  const span = trace.getActiveSpan();
  if (!span) return;

  span.setAttribute(key, value);
}

/**
 * Record exception on current span
 */
function recordException(error) {
  const span = trace.getActiveSpan();
  if (!span) return;

  span.recordException(error);
  span.setStatus({ code: 2, message: error.message }); // ERROR status
}

/**
 * Express middleware for tracing
 */
function tracingMiddleware(req, res, next) {
  const tracer = getTracer();
  if (!tracer) {
    return next();
  }

  const span = tracer.startSpan(`HTTP ${req.method} ${req.path}`);
  
  // Add request attributes
  span.setAttribute('http.method', req.method);
  span.setAttribute('http.url', req.url);
  span.setAttribute('http.target', req.path);
  span.setAttribute('http.host', req.hostname);
  span.setAttribute('http.scheme', req.protocol);
  span.setAttribute('http.user_agent', req.get('user-agent'));
  
  // Add user ID if available
  const userId = req.headers['x-user-id'];
  if (userId) {
    span.setAttribute('user.id', userId);
  }

  // Run handler in span context
  context.with(trace.setSpan(context.active(), span), () => {
    // Capture response
    const originalSend = res.send;
    res.send = function(data) {
      span.setAttribute('http.status_code', res.statusCode);
      span.end();
      return originalSend.call(this, data);
    };

    next();
  });
}

/**
 * Trace a job lifecycle
 */
function traceJobLifecycle(jobId, userId) {
  const tracer = getTracer();
  if (!tracer) return null;

  const span = tracer.startSpan('job.lifecycle', {
    attributes: {
      'job.id': jobId,
      'user.id': userId,
      'job.start_time': new Date().toISOString()
    }
  });

  return {
    span,
    addEvent: (event, attrs = {}) => span.addEvent(event, { ...attrs, timestamp: Date.now() }),
    end: () => span.end()
  };
}

/**
 * Trace presign operation
 */
function tracePresign(filename, contentType, fileSizeBytes) {
  return withSpan('presign', async (fn) => fn(), {
    'file.name': filename,
    'file.content_type': contentType,
    'file.size_bytes': fileSizeBytes,
    'operation': 'presign'
  });
}

/**
 * Trace upload operation
 */
function traceUpload(jobId, userId, fileCount, totalSizeMb) {
  return withSpan('upload', async (fn) => fn(), {
    'job.id': jobId,
    'user.id': userId,
    'file.count': fileCount,
    'file.total_size_mb': totalSizeMb,
    'operation': 'upload'
  });
}

/**
 * Trace worker operation
 */
function traceWorker(jobId, workerType, parentJobId) {
  return withSpan(`worker.${workerType}`, async (fn) => fn(), {
    'job.id': jobId,
    'job.parent_id': parentJobId,
    'worker.type': workerType,
    'operation': 'worker'
  });
}

module.exports = {
  initializeTracing,
  getTracer,
  startSpan,
  withSpan,
  addEvent,
  setAttribute,
  recordException,
  tracingMiddleware,
  traceJobLifecycle,
  tracePresign,
  traceUpload,
  traceWorker
};
